// Experiment with System.Threading.Interlocked
// sestoft@itu.dk * 2012-10-11

using System;
using System.Threading;

class MyTest {
  public static void Main(String[] args) {
    IntAdd();
    LongAdd();
  }

  public static void IntAdd() {
    int x = 64;
    Interlocked.Increment(ref x);
    Console.WriteLine(x);
    Interlocked.CompareExchange(ref x, x+1, 65);
    Console.WriteLine(x);
  }

  public static void LongAdd() {
    long x = 200;
    Interlocked.Increment(ref x);
    Console.WriteLine(x);
    Interlocked.CompareExchange(ref x, x+1, 201L);
    Console.WriteLine(x);
  }
}

/* gmcs generated bytecode for IntAdd (LongAdd similar):

00:  ldc.i4.s 0x40
02:  stloc.0 
03:  ldloca.s 0
05:  Interlocked::Increment([out] int32&)
0a:  pop 
0b:  ldloc.0 
0c:  Console::WriteLine(int32)
11:  ldloca.s 0
13:  ldloc.0 
14:  ldc.i4.1 
15:  add 
16:  ldc.i4.s 0x41
18:  Interlocked::CompareExchange([out] int32&, int32, int32)
1d:  pop 
1e:  ldloc.0 
1f:  Console::WriteLine(int32)


Mono runtime 2.10.9 JITted code for x86-64 for IntAdd: 
(very similar for Mono 3.2.3)

x is 0xfc(%rbp), with address temporarily in %rax

06 movl    $0x00000000,0xfc(%rbp)
0d movl    $0x00000040,0xfc(%rbp)
14 leal    0xfc(%rbp),%eax
17 movl    $0x00000001,%ecx
1c pushq   %rbx
1d movl    %ecx,%ebx
1f lock/xaddl      %ebx,(%rax)

23 addl    %ecx,%ebx
25 movl    %ebx,%eax
27 popq    %rbx
28 movl    0xfc(%rbp),%eax
2b subl    $0x0c,%esp
2e pushq   %rax
2f callq   0x0000005c
34 addl    $0x10,%esp

37 leal    0xfc(%rbp),%ecx
3a movl    0xfc(%rbp),%edx
3d movl    $0x00000041,%eax
43 lock/cmpxchgl   %edx,(%rcx)
47 movl    0xfc(%rbp),%eax

4a subl    $0x0c,%esp
4d pushq   %rax
4e nop
4f callq   0x0000005c


Mono 4.4.2 JITted code for x86 (32 bit?) for IntAdd 2016-11-07:

x is -0x10(%ebp) with address temporarily in %eax

09 movl    $0x0, -0x10(%ebp)
10 movl    $0x40, -0x10(%ebp)
17 leal    -0x10(%ebp), %eax
1a movl    $0x1, %ecx
1f pushl   %ebx
20 movl    %ecx, %ebx
22 lock
23 xaddl   %ebx, (%eax)
26 addl    %ecx, %ebx
28 movl    %ebx, %eax
2a popl    %ebx
2b movl    -0x10(%ebp), %eax
2e movl    %eax, (%esp)
31 movl    %eax, %eax
33 calll   0x60
38 leal    -0x10(%ebp), %ecx
3b movl    -0x10(%ebp), %edx
3e incl    %edx
3f movl    $0x41, %eax
44 lock
45 cmpxchgl        %edx, (%ecx)
48 movl    -0x10(%ebp), %eax
4b movl    %eax, (%esp)
4e nop
4f calll   0x60
54 leal    -0xc(%ebp), %esp
57 leal    -0xc(%ebp), %esp

 */

/* Mono 2.10.9 JITted code for x86-64 for LongAdd: 
   (very similar for Mono 3.2.3)

06        movl    $0x00000000,0xf0(%rbp)
0d        movl    $0x00000000,0xf4(%rbp)
14        movl    $0x000000c8,0xf0(%rbp)
1b        movl    $0x00000000,0xf4(%rbp)
22        leal    0xf0(%rbp),%eax
25        subl    $0x0c,%esp
28        pushq   %rax
29        movl    %eax,%eax
2b        callq   0x000000ac    ;; presumably Increment(ref long)
30        addl    $0x10,%esp
33        movl    %edx,0xfc(%rbp)
36        movl    %eax,0xf8(%rbp)
39        movl    0xf0(%rbp),%eax
3c        movl    0xf4(%rbp),%ecx
3f        subl    $0x08,%esp
42        pushq   %rcx
43        pushq   %rax
44        leal    0x00(%rbp),%ebp
47        callq   0x00000094
4c        addl    $0x10,%esp
4f        leal    0xf0(%rbp),%eax
52        movl    0xf0(%rbp),%ecx
55        movl    0xf4(%rbp),%edx
58        addl    $0x01,%ecx
5b        adcl    $0x00,%edx
5e        subl    $0x0c,%esp
61        pushq   $0x00
63        pushq   $0x000000c9
68        pushq   %rdx
69        pushq   %rcx
6a        pushq   %rax
6b        callq   0x000000a0	;; presumably CompareExchange(ref long, long, long)
70        addl    $0x20,%esp
73        movl    %edx,0xfc(%rbp)
76        movl    %eax,0xf8(%rbp)
79        movl    0xf0(%rbp),%eax
7c        movl    0xf4(%rbp),%ecx
7f        subl    $0x08,%esp
82        pushq   %rcx
83        pushq   %rax
84        leal    0x00(%rbp),%ebp
87        callq   0x00000094

 */
