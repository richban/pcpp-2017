Exercise 1.2
 1) Describe a scenario involving the two threads where this happens.
  Both threads end up sleeping 50 miliseconds before writing a bar, but the time where they started sleeping alternate as
  there is no guarantee that both threads will be at the same line of execution at any time.
  DAVIDE CORRIGE: I think they wanted something like the following.
  Thread 1 writes the pipe, then the system schedules Thread 2 which prints both the pipe and the dash and finally Thread 1 resumes printing a dash again.

 2) Explain why.
  The synchronized keyword on a method creates an exclusive lock on the instance object of Printer. Since both threads are
  accessing the same instance of Printer, this locking will ensure mutual exclusion on the print() method, hence making the
  race condition that results in improper output impossible.

  3) and 4) DAVIDE NOTE: Should we sumbit code snippets? At least for 3), since it would be overridden by 4)

Exercise 1.4

1) Time it took using Measure-Command in windows powershell: 6699ms

2) It is faster, 10 thread version takes 3152ms according to Measure-Command in windows powershell.

3) No, because incrementing using count = count + 1 is no longer atomic. Furthremore, 64 bit java uses long primitives that when changed involves changing two seperate 32 bit registers that are not threadsafe. (DAVIDE NOTE: Are you sure? I think your machine is 64 bit, but they might not be used in the ALU as far as I know)

4) In theory synchronization promises visibility and count is also not a volatile variable, so there will be no promise of visibility. 
   Entering a synchronized block will have all changes visible to you, exiting a block will ensure that changes are written to memory and thus visible to other other threads.
   Therefore theoretically it is possible that a thread B won't see the changes of thread A if synchronized is not in the getter as well.



Exercise 1.6

1) Explain the simplest natural way to make class DoubleArrayList thread-safe so it can be used from multiple concurrent threads.
   The simplest way would be to simply 
 To lock on the variable "items" or an object in all methods interacting with it. Another would be to put a synchronized keyword in the method defintion.

2) Discuss how well the thread-safe version of the class is likely scale if a large number of threads call get, add and set concurrently?
  Not well, since locking is basically serializing parallel execution. ndeed, each thread takes ownership of the same lock regardless of which method they call under DoubleArrayList. Therefore this solution
  is not ideal performance, but it is thread-safe and simplistic.

3) Now your notorious colleague Ulrik Funder suggests to improve the code by introducing a separate lock for each method, roughly as follows:

   Would this achieve thread-safety? Explain why not. Would it achieve visibility? Explain why not.

   No it would not, it will only be thread-safe on the particular method, but say we add an item that resizes the array by creating a new array and fills it. The ToString would
   output a bunch of default values for the array as the other thread has not completed updating the array.
   

Exercise 1.7

1) Explain how one can make the class thread-safe enough so that the totalSize field is maintained correctly
even if multiple concurrent threads work on multiple DoubleArrayList instances at the same time.
You may ignore the allLists field for now.

You could make totalSize volatile. Furthermore totalSize++; is not atomic. Therefore mutural exclusion should make a synchronized block for that statement under add, locking on the metaclass instance.

2)  Explain how one can make the class thread-safe enough so that the allLists field is maintained correctly even if multiple concurrent threads create new DoubleArrayList instances at the same time.


allLists is not thread-safe. Therefore there must be synchronization on calls to allLists methods. Creation of new DoubleArrayLists are thread-safe, but calling methods on the static allLists is not. The locking must be on the allLists object as the class itself is not static and
multiple instances therefore would allow for multiple locks to be obtained if this was used. DAVIDE: volatile?


