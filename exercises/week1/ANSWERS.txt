Exercise 1.2
 1) Describe a scenario involving the two threads where this happens.
  Thread 1 writes the vertical bar, then the system schedules Thread 2 which prints both the vertical bar and the dash and finally Thread 1 resumes printing a dash again.

 2) Explain why.
  The synchronized keyword on a method creates an exclusive lock on the instance object of Printer. Since both threads are
  accessing the same instance of Printer, this locking will ensure mutual exclusion on the print() method, hence making the
  race condition that results in improper output impossible.

  3) and 4) 
    See Printer.java and PrinterTester.java

Exercise 1.4

1) Time it took using Measure-Command in windows powershell: 6699ms

2) It is faster, 10 thread version takes 3152ms according to Measure-Command in windows powershell.

3) No, because incrementing using count = count + 1 is no longer atomic. Furthermore according to Java Concurrency in Practice, 64-bit long and double values to be treated as two 32-bit values.
Java language specification for Java 8 at the bottom of this link: http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.7 also says the following:
a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.

In other words writing/reading long are not treatsafe or atomic regardless of using 32bit or 64bit and as such count should be made volatile, be turned into AtomicLong or have some sort of synchronization like before.

4) In theory synchronization promises visibility and count is also not a volatile variable, so there will be no promise of visibility. 
   Entering a synchronized block will have all changes visible to you, exiting a block will ensure that changes are written to memory and thus visible to other other threads.
   Therefore theoretically it is possible that a thread B won't see the changes of thread A if synchronized is not in the getter as well.



Exercise 1.6

1) Explain the simplest natural way to make class DoubleArrayList thread-safe so it can be used from multiple concurrent threads.
   The simplest way would be to simply 
 To lock on the variable "items" or an object in all methods interacting with it. Another would be to put a synchronized keyword in the method defintion.

2) Discuss how well the thread-safe version of the class is likely scale if a large number of threads call get, add and set concurrently?
  Not well, since locking is basically serializing parallel execution. ndeed, each thread takes ownership of the same lock regardless of which method they call under DoubleArrayList. Therefore this solution
  is not ideal performance, but it is thread-safe and simplistic.

3) Now your notorious colleague Ulrik Funder suggests to improve the code by introducing a separate lock for each method, roughly as follows:

   Would this achieve thread-safety? Explain why not. Would it achieve visibility? Explain why not.

   No it would not, it will only be thread-safe on the particular method, but say we add an item that resizes the array by creating a new array and fills it. The ToString would
   output a bunch of default values for the array as the other thread has not completed updating the array.
   

Exercise 1.7

1) Explain how one can make the class thread-safe enough so that the totalSize field is maintained correctly
even if multiple concurrent threads work on multiple DoubleArrayList instances at the same time.
You may ignore the allLists field for now.

You could make totalSize volatile. Furthermore totalSize++; is not atomic. Therefore mutural exclusion should make a synchronized block for that statement under add.

2)  Explain how one can make the class thread-safe enough so that the allLists field is maintained correctly even if multiple concurrent threads create new DoubleArrayList instances at the same time.


allLists is not thread-safe. Therefore there must be synchronization on calls to allLists methods. Creation of new DoubleArrayLists are thread-safe, but calling methods on the static allLists is not. The locking must be on the allLists object as the class itself is not static and
multiple instances therefore would allow for multiple locks to be obtained if this was used.


Exercise 1.8

1) Explain why after 10 million calls to MysteryB.increment() and 10 million concurrent calls to MysteryB.increment4(), the resulting value of count is rarely the expected 50,000,000

Syncronizing the static method makes a synchronize block in the body that syncronize on MysteryB.class. MysteryA increment will do the same but on MysteryA.class. Point here is that
access and changes to the shared value count that needs to be syncronized is syncronized using locks obtained from two different objects. Therefore we get a wrong result as there is 
actually not proper mutural exclusion going on.

2) Explain how one can use an explicit lock object and synchronized statements (not synchronized methods) to change the locking scheme, so that the result is always the expected 50,000,000.


Make a syncronize block on increment that locks on MysteryA.class or an object in MysteryA that is available for both MysteryA and MysteryB. (CHECK BEFORE HANDIN).
